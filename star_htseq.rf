param (
    // S3 path to read1 of the fastq/fasta file. If multiple files, 
    // can be pipe-separated e.g. sample1_01.fastq|sample1_02.fastq
    read1 string

    // S3 path to read2 of the fastq/fasta file. If multiple files, 
    // can be pipe-separated e.g. sample1_01.fastq|sample1_02.fastq
    read2 string

    // Identifier of the sample
    name string

    // Full s3 folder location to copy alignment output and htseq 
    // results. Each sample is output to a folder.
    output string

    // Only mouse/vM19 is supported for now. Must be a subfolder in
    // the reference containing *.genome.fa and *.annotation.gtf files
    genome = "mouse/vM19"

    // If "west", use the us-west-2 bucket s3://czbiohub-reference
    //      for the reference genome,
    // if "east", use the us-east-1 bucket s3://czbiohub-reference-east
    //      for the reference genome
    region = "west"
)


val files = make("$/files")
val dirs = make("$/dirs")

// Local utility file
val util = make("./util.rf")

ubuntu := "ubuntu:16.04"
star := "quay.io/biocontainers/star:2.6.0c--0"
samtools := "biocontainers/samtools"
htseq := "quay.io/biocontainers/htseq:0.9.1--py36_0"

reference_bucket := if region == "west" {
        "s3://czbiohub-reference/" } else {
        "s3://czbiohub-reference-east/"
    }

func DecompressReference(tgz file) = {
    outdir := exec(image := ubuntu, mem := 32*GiB) (outdir dir) {"
        tar -C {{outdir}} -xzvf {{tgz}} 
    "}
    outdir := trace(outdir)
    val (fasta, _) = dirs.Pick(outdir, "*/*.fa*")
    val (gtf, _) = dirs.Pick(outdir, "*/*.gtf")

    {fasta, gtf}
}

func starIndex(fasta, gtf file) (out dir) =
    exec(image := star, mem := 32*GiB) (out dir) {"
        STAR \
        --runThreadN 12 \
        --runMode genomeGenerate \
        --genomeDir {{out}} \
        --genomeFastaFiles {{fasta}} \
        --sjdbGTFfile {{gtf}}
    "}

func starAlign(read1, read2 [file], genomeDir dir) = 
    exec(image := star, mem := 12*GiB, cpu := 12) (out dir) {"
        cd {{out}}
        STAR --outFilterType BySJout \
            --outFilterMultimapNmax 20 \
            --alignSJoverhangMin 8 \
            --alignSJDBoverhangMin 1 \
            --outFilterMismatchNmax 999 \
            --outFilterMismatchNoverLmax 0.04 \
            --alignIntronMin 20 \
            --alignIntronMax 1000000 \
            --alignMatesGapMax 1000000 \
            --outSAMstrandField intronMotif \
            --outSAMtype BAM Unsorted \
            --outSAMattributes NH HI NM MD \
            --outReadsUnmapped Fastx \
            --readFilesCommand zcat \
            --runThreadN 12 \
            --genomeDir {{genomeDir}} \
            --readFilesIn {{read1}} {{read2}}
    "}

func samSort(aligned file) = 
    exec (image := samtools, mem := 20*GiB) (sorted file) {"
        samtools sort -m 18GB -o {{sorted}} {{aligned}}
    "}


func samIndex(sorted file) =
    exec(image := samtools, mem := GiB) (index file) {"
        samtools index -b {{sorted}} {{index}}
    "}

func samSortByName(sorted file) = 
    exec(image := samtools, mem := 20*GiB) (byname file) {"
        samtools sort -m 18GB -n -o {{byname}} {{sorted}}
    "}


func htseqCount(byName, gtf file) =
   exec(image := htseq, mem := GiB) (counts file) {"
     htseq-count -r name -s no -f bam -m intersection-nonempty {{byName}} {{gtf}} > {{counts}}
   "}

val Main = {
    output := util.MaybeAddTrailingSlash(output)

    r1 := util.SplitByPipe(read1)
    r2 := util.SplitByPipe(read2)

    tgz := file(reference_bucket + genome + ".tgz")
    val reference = DecompressReference(tgz)

    val index = starIndex(reference.fasta, reference.gtf)
    val alignment_dir = starAlign(r1, r2, index)
    
    val (aligned, _) = dirs.Pick(alignment_dir, "*Aligned.out.bam")
    val sorted = samSort(aligned)
    val index = samIndex(sorted)
    val byName = samSortByName(sorted)
    val counts = htseqCount(byName, reference.gtf)

    count_dir := dirs.Make(["htseq-count.txt": counts])

    output_dirs := [alignment_dir, count_dir]
    [dirs.Copy(d, output) | d <- output_dirs]
}
