
idseq := "czbiohub/idseq-dag"

dirs := make("$/dirs")
files := make("$/files")

fileutils := make("./fileutils.rf")


// PriceSeqFilter -f Exp_12F_A08_S8_R1_001.fastq -o Exp_12F_A08_S8_R1_001_PF.fastq -a 12 -rnf 90 -log c -rqf 85 0.98
// # PriceSeqFilter
// PRICE Sequence Filter v1.2


// These are the command options for the PRICE sequence filter. 
// For more details, see the accompanying README.txt file. 
// To run the PRICE assembler, use the executable: PriceTI. 
// Contact: price@derisilab.ucsf.edu 

// Usage: ./PriceSeqFilter [args] 

// INPUT/OUTPUT FILES: 
//  accepted formats are fasta (appended .fa, .fasta, .fna, .ffn, .frn), fastq (.fq, .fastq, or _sequence.txt), or priceq (.pq or .priceq) 
//   NOTE ABOUT FASTQ ENCODING: multiple encodings are currently used for fastq quality scores.  The traditional encoding is Phred+33,
//                              and PRICE will interpret scores from any .fq or .fastq file according to that encoding.  The Phred+64 
//                              encoding has been used extensively by Illumina, and so it is applied to Illumina's commonly-used _sequence.txt
//                              file append.  Please make sure that your encoding matches your file append.
// INPUT FILES: 
//  -f <a>: (a) input file of non-paired sequences. 
//  -fp <a> <b> (a,b) two input files of sequences; the sequences in one file are the paired-ends of those in the other.
// OUTPUT FILES: 
//  -o <a>: (a) output file of non-paired sequences. 
//  -op <a> <b> (a,b) two output files of sequences; the sequences in one file are the paired-ends of those in the other.

// OTHER PARAMS: 
//  -r <a>: (a) alignment score reward for a nucleotide match; should be a positive integer (default=1)
//  -q <a>: (a) alignment score penalty for a nucleotide mismatch; should be a negative integer (default=-2)
//  -G <a>: (a) alignment score penalty for opening a gap; should be a negative integer (default=-5)
//  -E <a>: (a) alignment score penalty for extending a gap; should be a negative integer (default=-2)

// FILTERING RULES: 
// -pair <a>:  <a> is "both" or "either", describing whether both reads of a pair or either read of a pair must FAIL 
//             the filters in order for the entire pair to be removed.  If paired files are used as input, the read pairs 
//             will be retained or discarded together.  If you want the sequences to be individually evaluated, run twice 
//             using each file as an individual (non-paired) input file. (default=either)

// FILTERING SEQUENCES: 
//  -rqf <a> <b>: filters out sequences with an unaccptably high number of low-quality nucleotides, as defined by the provided 
//                quality scores (only applies to files whose formats include quality score information). 
//                (a) the percentage of nucleotides in a read that must be high-quality; (b) the minimum allowed probability
//                of a nucleotide being correct (must be between 0 and 1, and will usually be a decimal value close to 1);
//  -rnf <a>: filters pairs of reads if either has an unaccptably high number of uncalled nucleotides (Ns or other ambiguous
//                IUPAC codes).  Like -rqf, but will also filter fasta-format data.  (a) the percentage of nucleotides in a read
//                that must be called
//  -maxHp <a>: filters out a pair of reads if either read has a homo-polymer track >(a) nucleotides in length.
//  -maxDi <a>: filters out a pair of reads if either read has a repeating di-nucleotide track >(a) nucleotides in length.
//            NOTE: this will also catch mono-nucleotide repeats of the specified length (a string of A's is also a string
//            of AA's), so calling -maxHp in addition to -maxDi is superfluous unless -maxHp is given a smaller max value.
//  -badf <a> <b>: sequences fail if they match with at least (b)% identity to a sequence in file (a).
//  -goodf <a> <b>: sequences fail if they DON'T match with at least (b)% identity to a sequence in file (a).
//  -lenf <a>: filters out sequences shorter than (a) nt 

// COMPUTATIONAL EFFICIENCY: 
//  -a <x>: (x)num threads to use (default=1) 

// USER INTERFACE: 
//  -log <a>: determines the type of output:
//          (a) = c: concise stdout (default)
//          (a) = n: no stdout 
//  -, -h, or --help: user interface info. 

// No sequence filter was run; help message printed instead.
func PriceSeqFilter(fastq_gz file) = {

	unzipped := fileutils.Gunzip(fastq_gz)

	d := dirs.Make(["reads.fastq": unzipped])

    output := exec (image := idseq, mem := 2*GiB) (output dir) {"
        PriceSeqFilter -f {{d}}/reads.fastq \
            -o {{output}}/filtered.fastq \
        	-a 12 \
            -rnf 90 -log c -rqf 85 0.98
    "}
    val (filtered, _) = dirs.Pick(output, "*.fastq")
    filtered
}

// root@df77c2506af7:/# bowtie2
// No index, query, or output file specified!
// Bowtie 2 version 2.3.2 by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)
// Usage: 
//   bowtie2 [options]* -x <bt2-idx> {-1 <m1> -2 <m2> | -U <r> | --interleaved <i>} [-S <sam>]

//   <bt2-idx>  Index filename prefix (minus trailing .X.bt2).
//              NOTE: Bowtie 1 and Bowtie 2 indexes are not compatible.
//   <m1>       Files with #1 mates, paired with files in <m2>.
//              Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
//   <m2>       Files with #2 mates, paired with files in <m1>.
//              Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
//   <r>        Files with unpaired reads.
//              Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
//   <i>        Files with interleaved paired-end FASTQ reads
//              Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
//   <sam>      File for SAM output (default: stdout)

//   <m1>, <m2>, <r> can be comma-separated lists (no whitespace) and can be
//   specified many times.  E.g. '-U file1.fq,file2.fq -U file3.fq'.

// Options (defaults in parentheses):

//  Input:
//   -q                 query input files are FASTQ .fq/.fastq (default)
//   --tab5             query input files are TAB5 .tab5
//   --tab6             query input files are TAB6 .tab6
//   --qseq             query input files are in Illumina's qseq format
//   -f                 query input files are (multi-)FASTA .fa/.mfa
//   -r                 query input files are raw one-sequence-per-line
//   -c                 <m1>, <m2>, <r> are sequences themselves, not files
//   -s/--skip <int>    skip the first <int> reads/pairs in the input (none)
//   -u/--upto <int>    stop after first <int> reads/pairs (no limit)
//   -5/--trim5 <int>   trim <int> bases from 5'/left end of reads (0)
//   -3/--trim3 <int>   trim <int> bases from 3'/right end of reads (0)
//   --phred33          qualities are Phred+33 (default)
//   --phred64          qualities are Phred+64
//   --int-quals        qualities encoded as space-delimited integers

//  Presets:                 Same as:
//   For --end-to-end:
//    --very-fast            -D 5 -R 1 -N 0 -L 22 -i S,0,2.50
//    --fast                 -D 10 -R 2 -N 0 -L 22 -i S,0,2.50
//    --sensitive            -D 15 -R 2 -N 0 -L 22 -i S,1,1.15 (default)
//    --very-sensitive       -D 20 -R 3 -N 0 -L 20 -i S,1,0.50

//   For --local:
//    --very-fast-local      -D 5 -R 1 -N 0 -L 25 -i S,1,2.00
//    --fast-local           -D 10 -R 2 -N 0 -L 22 -i S,1,1.75
//    --sensitive-local      -D 15 -R 2 -N 0 -L 20 -i S,1,0.75 (default)
//    --very-sensitive-local -D 20 -R 3 -N 0 -L 20 -i S,1,0.50

//  Alignment:
//   -N <int>           max # mismatches in seed alignment; can be 0 or 1 (0)
//   -L <int>           length of seed substrings; must be >3, <32 (22)
//   -i <func>          interval between seed substrings w/r/t read len (S,1,1.15)
//   --n-ceil <func>    func for max # non-A/C/G/Ts permitted in aln (L,0,0.15)
//   --dpad <int>       include <int> extra ref chars on sides of DP table (15)
//   --gbar <int>       disallow gaps within <int> nucs of read extremes (4)
//   --ignore-quals     treat all quality values as 30 on Phred scale (off)
//   --nofw             do not align forward (original) version of read (off)
//   --norc             do not align reverse-complement version of read (off)
//   --no-1mm-upfront   do not allow 1 mismatch alignments before attempting to
//                      scan for the optimal seeded alignments
//   --end-to-end       entire read must align; no clipping (on)
//    OR
//   --local            local alignment; ends might be soft clipped (off)

//  Scoring:
//   --ma <int>         match bonus (0 for --end-to-end, 2 for --local) 
//   --mp <int>         max penalty for mismatch; lower qual = lower penalty (6)
//   --np <int>         penalty for non-A/C/G/Ts in read/ref (1)
//   --rdg <int>,<int>  read gap open, extend penalties (5,3)
//   --rfg <int>,<int>  reference gap open, extend penalties (5,3)
//   --score-min <func> min acceptable alignment score w/r/t read length
//                      (G,20,8 for local, L,-0.6,-0.6 for end-to-end)

//  Reporting:
//   (default)          look for multiple alignments, report best, with MAPQ
//    OR
//   -k <int>           report up to <int> alns per read; MAPQ not meaningful
//    OR
//   -a/--all           report all alignments; very slow, MAPQ not meaningful

//  Effort:
//   -D <int>           give up extending after <int> failed extends in a row (15)
//   -R <int>           for reads w/ repetitive seeds, try <int> sets of seeds (2)

//  Paired-end:
//   -I/--minins <int>  minimum fragment length (0)
//   -X/--maxins <int>  maximum fragment length (500)
//   --fr/--rf/--ff     -1, -2 mates align fw/rev, rev/fw, fw/fw (--fr)
//   --no-mixed         suppress unpaired alignments for paired reads
//   --no-discordant    suppress discordant alignments for paired reads
//   --dovetail         concordant when mates extend past each other
//   --no-contain       not concordant when one mate alignment contains other
//   --no-overlap       not concordant when mates overlap at all

//  Output:
//   -t/--time          print wall-clock time taken by search phases
//   --un <path>        write unpaired reads that didn't align to <path>
//   --al <path>        write unpaired reads that aligned at least once to <path>
//   --un-conc <path>   write pairs that didn't align concordantly to <path>
//   --al-conc <path>   write pairs that aligned concordantly at least once to <path>
//   (Note: for --un, --al, --un-conc, or --al-conc, add '-gz' to the option name, e.g.
//   --un-gz <path>, to gzip compress output, or add '-bz2' to bzip2 compress output.)
//   --quiet            print nothing to stderr except serious errors
//   --met-file <path>  send metrics to file at <path> (off)
//   --met-stderr       send metrics to stderr (off)
//   --met <int>        report internal counters & metrics every <int> secs (1)
//   --no-unal          suppress SAM records for unaligned reads
//   --no-head          suppress header lines, i.e. lines starting with @
//   --no-sq            suppress @SQ header lines
//   --rg-id <text>     set read group id, reflected in @RG line and RG:Z: opt field
//   --rg <text>        add <text> ("lab:value") to @RG line of SAM header.
//                      Note: @RG line only printed when --rg-id is set.
//   --omit-sec-seq     put '*' in SEQ and QUAL fields for secondary alignments.
//   --sam-noqname-trunc Suppress standard behavior of truncating readname at first whitespace 
//                       at the expense of generating non-standard SAM.

//  Performance:
//   -p/--threads <int> number of alignment threads to launch (1)
//   --reorder          force SAM output order to match order of input reads
//   --mm               use memory-mapped I/O for index; many 'bowtie's can share

//  Other:
//   --qc-filter        filter out reads that are bad according to QSEQ filter
//   --seed <int>       seed for random number generator (0)
//   --non-deterministic seed rand. gen. arbitrarily instead of using read attributes
//   --version          print version information and quit
//   -h/--help          print this usage message
// (ERR): bowtie2-align exited with value 1
func BowtieAlign(read1, read2 file, index dir, index_id string) = 
    exec (image := idseq, mem := 2*GiB) (sam, aligned_concordant, log file) {"
    	cd {{index}}
        bowtie2 -p12 -x {{index_id}} -q \
        	-1 {{read1}} \
        	-2 {{read2}} \
        	--very-sensitive-local \
        	-S {{sam}} \
        	--no-unal --al-conc {{aligned_concordant}} \
        	2>> {{log}}
    "}


// root@df77c2506af7:/# bowtie2-build
// No input sequence or sequence file specified!
// Bowtie 2 version 2.3.2 by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)
// Usage: bowtie2-build [options]* <reference_in> <bt2_index_base>
//     reference_in            comma-separated list of files with ref sequences
//     bt2_index_base          write bt2 data to files with this dir/basename
// *** Bowtie 2 indexes work only with v2 (not v1).  Likewise for v1 indexes. ***
// Options:
//     -f                      reference files are Fasta (default)
//     -c                      reference sequences given on cmd line (as
//                             <reference_in>)
//     --large-index           force generated index to be 'large', even if ref
//                             has fewer than 4 billion nucleotides
//     -a/--noauto             disable automatic -p/--bmax/--dcv memory-fitting
//     -p/--packed             use packed strings internally; slower, less memory
//     --bmax <int>            max bucket sz for blockwise suffix-array builder
//     --bmaxdivn <int>        max bucket sz as divisor of ref len (default: 4)
//     --dcv <int>             diff-cover period for blockwise (default: 1024)
//     --nodc                  disable diff-cover (algorithm becomes quadratic)
//     -r/--noref              don't build .3/.4 index files
//     -3/--justref            just build .3/.4 index files
//     -o/--offrate <int>      SA is sampled every 2^<int> BWT chars (default: 5)
//     -t/--ftabchars <int>    # of chars consumed in initial lookup (default: 10)
//     --threads <int>         # of threads
//     --seed <int>            seed for random number generator
//     -q/--quiet              verbose output (for debugging)
//     -h/--help               print detailed description of tool and its options
//     --usage                 print this usage message
//     --version               print version information and quit
func BowtieIndex(fasta file, id string) = 
    exec (image := idseq, mem := 2*GiB) (index dir) {"
    	cd {{index}}
		bowtie2-build {{fasta}} {{id}}
    "}


@requires(cpu := 8)
val Main = {
	id := "Exp_12F_A01_S1"
	read1 := "s3://czb-seqbot/fastqs/181022_NB501961_0176_AH532CAFXY/Exp_12F_A01_S1_R1_001.fastq.gz"
	read2 := "s3://czb-seqbot/fastqs/181022_NB501961_0176_AH532CAFXY/Exp_12F_A01_S1_R2_001.fastq.gz"
	genome_fasta := file("s3://czbiohub-reference/elephant.fasta")
	genome_id := "elephant"

	output := "s3://olgabot-maca/kalani-elephant-reflow/"

	r1 := file(read1)
	r2 := file(read2)

	r1_filtered := PriceSeqFilter(r1)
	r2_filtered := PriceSeqFilter(r2)

	genome_index := BowtieIndex(genome_fasta, genome_id)
	val (sam, aligned_concordant, log) = BowtieAlign(r1_filtered, r2_filtered, 
		genome_index, genome_id)

	aligned := dirs.Make([id + ".sam": sam, id + ".log": log])

	// [files.Copy(f, output + id + read_number + "_filtered.fastq") | (read_number, f) <- read_filtered]
	dirs.Copy(aligned, output + "aligned/")
}
